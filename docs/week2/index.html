
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Week 2: Smart Contract 개발</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="html"
                  title="Week 2: Smart Contract 개발"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="세션 소개" duration="5">
        <p>이번 세션은 Solidity를 사용하여 Smart Contract 개발에 대해 이해하는 것이 목적입니다. 여러분은 단순히 문법을 배우는 것을 넘어, 이더리움 생태계의 핵심 원리를 이해하고, 스마트 컨트랙트를 작성하여 블록체인 상에 배포하는 개발 과정을 경험하게 됩니다.</p>
<h2 is-upgraded>목차</h2>
<h3 is-upgraded>1. 요구사항 정리</h3>
<p>프로젝트의 요구사항을 정리하여 개발 계획을 세웁니다. 앞으로 어떤 기능을 구현해야하는지 알아봅시다.</p>
<h3 is-upgraded>2. 코드 뼈대 작성</h3>
<p>코드 폴더 구조를 살펴보아 전체적인 프로젝트의 틀을 마련합니다. 스마트 컨트랙트의 들어가 함수 목록과 함수의 반환값, 파라미터를 설정하여 코드의 전체적인 뼈대를 작성합니다.</p>
<h3 is-upgraded>3. 스마트 컨트랙트 작성</h3>
<p>코드 배포, 토큰 매매, 다운로드 요청 등 스마트 컨트랙트에 들어가야 할 기능을 구현합니다.</p>
<h3 is-upgraded>4. IPFS 사용법 익히기</h3>
<p>IPFS에 대해 알아보고 사용법을 익힙니다. 이를 바탕으로 파일 업로드/다운로드기능을 구현합니다.</p>
<h3 is-upgraded>5. 위원회 동작 방식의 이해</h3>
<p>사전에 작성되어 있는 코드를 참고하여 위원회 서버의 동작 방식을 이해합니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="요구사항 정리" duration="0">
        <p>아래의 요구사항은 저번 세션에 살펴보았던 요구사항들입니다.</p>
<h3 is-upgraded>기능 요구사항</h3>
<ul>
<li>User는 배포자, 위원회, 사용자로 구분됩니다. <ul>
<li>배포자: 코드를 배포한 사람</li>
<li>위원회: 라이센스를 검증하는 사람</li>
<li>사용자: 코드를 사용하는 사람</li>
</ul>
</li>
<li>배포자는 codeHash, cipherCid의 정보를 포함하여 코드를 등록할 수 있습니다.</li>
<li>배포자는 만료일과 실행 횟수를 지정하여 라이선스 토큰을 발급합니다.</li>
<li>사용자는 코드를 실행할 때마다 권한을 소진합니다. (잔여 횟수가 줄어듭니다)</li>
<li>위원회는 실행 건마다 암호화된 조각을 제출합니다.</li>
<li>배포자는 본인의 라이선스나 모든 코드 실행 요청을 중단, 허용할 수 있어야 합니다.</li>
<li>모든 동작은 이벤트로 기록되어 누구나 확인할 수 있습니다.</li>
<li>사용자는 오프체인 서명을 이용해 가스 없이 실행을 위임할 수 있습니다.(낮은 우선 순위)</li>
<li>위원회는 멤버를 관리하고 임계치(threshold)를 설정합니다.(낮은 우선 순위)</li>
</ul>
<h3 is-upgraded>비기능 요구사항</h3>
<ul>
<li>Hardhat, Remix, Metamask 등을 활용해 개발 환경을 구성합니다.</li>
<li>보안성: 키를 여러 위원에게 분산하여 보안을 강화합니다.</li>
<li>실행 전에는 로컬에서 코드 해시를 검증하여 무결성을 확인합니다.</li>
<li>저장 공간과 가스를 절약하기 위해 필요한 정보만 온체인에 기록합니다.</li>
<li>표준 토큰(ERC-1155/721) 규격을 사용하여 호환성을 확보합니다.</li>
<li>온체인에는 평문 코드를 저장하지 않고, 암호화된 파일만 IPFS에 저장합니다.</li>
<li>실행은 오프체인 환경(안전한 장소)에서 이루어지며, 실행 후 민감한 데이터는 즉시 삭제합니다.(낮은 우선 순위)</li>
<li>위원회 응답이 부족해도 서비스가 중단되지 않도록 여유 있게 구성합니다.(낮은 우선 순위)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="코드 뼈대 작성" duration="0">
        <p>본격적으로 코드를 작성해봅시다. 앞서 살펴보았던 기능을 구현하기 위해 Contract뿐만 아니라 코드를 배포하고 실행하기 위한 UI, key를 관리하기 위한 위원회 server등 다양한 요소가 필요합니다. Contract에 집중하기 위해 Contract를 제외한 부분의 코드는 사전에 작성되어 있습니다. 사전에 작성된 코드를 받아주도록 합시다.</p>
<pre><code language="language-bash" class="language-bash">git clone https://github.com/HYBLOCK-LAB/SOLiX.git
</code></pre>
<p>git이 설치가 안되어 있다면 <a href="https://github.com/HYBLOCK-LAB/SOLiX" target="_blank">여기</a>를 방문하여 zip파일로 다운받아주세요.</p>
<p>프로젝트는 모노레포로 구성되어 있으며 폴더 구조는 다음과 같습니다.</p>
<pre><code language="language-text" class="language-text">├── apps/ # 핵심 애플리케이션 모음
│ ├── committee/
│ │ └── ... # 키 관리를 위한 위원회 서버(off-chain)와 관련된 코드
│ ├── contracts/ # 프로젝트의 핵심 규칙과 데이터를 담은 On-chain 코드
│ │    ├── contracts/ # 실제 Smart Contract 소스 코드
│ │    ├── ignition/ # 실제 Smart Contract 소스 코드
│ │    ├── test/ # 테스트 코드
│ │    └── hardhat.config.ts/ # Hardhat 설정 파일. Solidity 버전이나 네트워크 설정 관리
│ └─── web/
│   └── ... # UI를 제공하는 코드
├── docker/
│ └── ... # 다양한 서비스들을 격리된 환경(Container)에서 실행할 수 있도록 도와주는 설정 파일
├── docs/
│ └── ... # git page로 제공되는 html 파일
├── session/
│ └── ... # docs를 만들기 위한 codelab 파일
├── README.md
└── Makefile # 프로젝트에 필요한 명령어. 단순한 단축키처럼 만들어놓은 파일

</code></pre>
<h3 is-upgraded>실행하는 법 적기</h3>
<h2 is-upgraded>Contract 구조</h2>
<p>프로젝트의 <code>apps/contracts/contracts</code>를 확인해주세요. <code>interfaces</code>폴더와 <code>CommitteeManager.sol</code>, <code>LicenseManager.sol</code>파일을 확인할 수 있을 겁니다.</p>
<p><strong>Interface</strong>는 특정 스마트 컨트랙트와 상호작용하기 위한 함수들의 명세서 또는 설계도입니다. 컨트랙트가 어떤 함수들을 가지고 있는지 알려주지만, 실제 코드는 포함하지 않습니다. interface는 이미 On-chain에 배포된 다른 컨트랙트의 함수를 내 컨트랙트에서 호출하고 싶을 때 사용합니다. 상대방 컨트랙트의 전체 소스코드를 다 가져올 필요 없이, 인터페이스만 가지고 있으면 해당 컨트랙트의 함수를 안전하고 효율적으로 호출할 수 있습니다. 이는 코드의 크기를 줄여 가스비를 절약할 수 있습니다. 또한, Interface에 맞게 Contract가 구성되므로 Contract에 어떤 기능이 있는지 쉽게 확인이 가능합니다.</p>
<p>기능을 구현하기 위해서 크게 두가지 기능이 필요합니다. 먼저, License를 실제로 발급하고 소비하는 License를 관리하는 Contract가 필요합니다. 두 번째로, 위원회에서 사용자에 대한 승인을 하고 분할된 키를 IPFS에 배포하기 위해 워원회를 관리하는 Contract가 필요합니다. 두 개의 Contract를 분리해서 작성할 예정입니다.</p>
<h3 is-upgraded>Contract에 필요한 사항들</h3>
<p>Contract를 구현하기 위해 필요한 사항을 정리해봅시다.</p>
<ul>
<li>contract는 code에 대한 정보를 알아야 합니다. <ul>
<li>등록된 code의 메타데이터와 등록된 code의 개수(다음에 등록할 코드에 대한 번호 부여 용도)</li>
<li>code의 owner는 누구인지</li>
</ul>
</li>
<li>code를 등록할 수 있어야 합니다. 등록을 하면 owner로 설정되어야 합니다.</li>
<li>owner는 라이센스 토큰 발급할 수 있어야 합니다.</li>
<li>owner는 모든 코드 실행 요청을 중단, 허용할 수 있어야 합니다.</li>
<li>라이센스 토큰으로 code실행을 위한 key를 요청할 수 있어야합니다. 이 요청을 위원회에 이벤트로 전달해야 합니다.</li>
</ul>
<p>이를 바탕으로 LincenseManager의 interface를 작성해줍시니다. 아래의 코드를 <code>ILicenseManager.sol</code>에 붙여넣어 주세요.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {IERC165} from &#34;@openzeppelin/contracts/utils/introspection/IERC165.sol&#34;;

interface ILicenseManager is IERC165 {
    /* ========= 상태 조회 ========= */

    // code 조회
    function code(
        uint256 codeId
    ) external view returns (bytes32, string memory, bool, bool);

    // 코드 소유자 조회
    function codeOwner(uint256 codeId) external view returns (address);

    // 계정별 라이선스 만료시간 조회
    function licenseExpiry(
        address account,
        uint256 codeId
    ) external view returns (uint256);

    // 다음에 등록할 코드 ID 조회
    function nextCodeId() external view returns (uint256);

    /* ========= 이벤트 ========= */
    // 코드 등록
    event CodeRegistered(
        uint256 indexed codeId,
        bytes32 codeHash,
        string cipherCid,
        address indexed publisher
    );

    // 코드 메타데이터 갱신
    event CodeUpdated(
        uint256 indexed codeId,
        bytes32 codeHash,
        string cipherCid,
        address indexed publisher
    );

    // 라이선스 발급
    event LicenseIssued(
        uint256 indexed codeId,
        address indexed to,
        uint256 runs,
        uint256 expiry
    );

    // 라이선스 취소
    event LicenseRevoked(
        uint256 indexed codeId,
        address indexed account,
        uint256 burned
    );

    // 코드 일시정지
    event CodePaused(uint256 indexed codeId);

    // 코드 일시정지 해제
    event CodeUnpaused(uint256 indexed codeId);

    // 코드 실행 요청
    event RunRequested(
        uint256 indexed codeId,
        address indexed user,
        bytes recipientPubKey,
        uint256 blockTimestamp
    );

    // ERC165 통합 오버라이드
    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    /* ========= 함수 정의 ========= */
    // 코드 등록
    function registerCode(
        bytes32 codeHash,
        string calldata cipherCid
    ) external returns (uint256 codeId);

    // 코드 메타데이터 갱신
    function updateCodeMetadata(
        uint256 codeId,
        bytes32 newCodeHash,
        string calldata newCipherCid
    ) external;

    // 코드 실행 일시정지
    function pauseCodeExecution(uint256 codeId) external;

    // 코드 실행 일시정지 해제
    function unpauseCodeExecution(uint256 codeId) external;

    // 라이센스 발급
    function issueLicense(
        uint256 codeId,
        address to,
        uint256 runs,
        uint256 expiryTimestamp
    ) external;

    // 라이센스 취소
    function revokeUserLicense(address account, uint256 codeId) external;

    // 코드 실행 요청
    function requestCodeExecution(
        uint256 codeId,
        bytes calldata recipientPubKey
    ) external;

    /* ========= View Helper ========= */

    function checkCodeActive(uint256 codeId) external view returns (bool);

    function checkCodeExists(uint256 codeId) external view returns (bool);

    function uri(uint256 id) external view returns (string memory);
}
</code></pre>
<h3 is-upgraded>상태 조회</h3>
<p><strong>code</strong></p>
<p>code를 조회하는 함수입니다. contract 내부에서 관리되는 <code>codeId</code>를 통해 조회할 수 있습니다. 반환값</p>
<ul>
<li>codeHash: 코드를 keccak256로 해시값.</li>
<li>cipherCid: 암호화된 코드의 IPFS CID.</li>
<li>paused: 코드 실행 요청 일시정지 여부.</li>
<li>exists: 코드 등록 여부.</li>
</ul>
<p><strong>codeOwner</strong></p>
<p>code에 대한 소유자를 조회하는 함수입니다. <code>codeId</code>를 통해 조회할 수 있습니다.</p>
<p>반환값</p>
<ul>
<li>owner: 해당 codeId의 등록 계정</li>
</ul>
<p><strong>licenseExpiry</strong></p>
<p>계정별 코드의 라이선스 만료 타임스탬프(초)를 조회합니다. 사용자의 <code>account</code>와 <code>codeId</code>를 통해 조회할 수 있습니다.</p>
<p>반환값</p>
<ul>
<li>expiryTimestamp: 블록의 타임스탬프. 0이면 미설정/만료 상태입니다.</li>
</ul>
<p><strong>nextCodeId</strong></p>
<p>다음에 등록할 코드 ID를 조회합니다. 코드를 등록할 때 내부적으로 코드 ID를 부여하기 위해 사용됩니다. getter함수를 만들었지만 실제로 사용되진 않습니다. nextCodeId는 현재 등록된 코드의 수와 동일합니다.</p>
<aside class="special"><p><strong>Tip: </strong>getter 함수</p>
<p>public 상태 변수는 컴파일러가 자동으로 getter함수를 생성준다는 점에서 internal 변수와 다릅니다. 이 getter함수 덕분에 다른 contract에서도 해당 변수의 값을 읽을 수 있습니다. </p>
<p> 하지만 다른 컨트랙트는 ABI를 알고 있지 않는 이상 해당 변수가 public인지 아닌지 알 방법이 없습니다. 이를 <strong>interface</strong>를 통해서 알 수 있습니다. 따라서 함수의 이름, 파라미터, 반환값을 동일하게 interface에 명시해주어야 합니다.</p>
</aside>
<h3 is-upgraded>이벤트</h3>
<p>함수와 구분짓기 위해 이벤트 명은 <strong>명사 + 과거분사</strong> 형태로 작성하였습니다. 이는 (Coinbase의 스타일 컨벤션)[https://github.com/coinbase/solidity-style-guide]이기도 합니다.</p>
<p><strong>CodeRegistered</strong></p>
<p>새로운 코드가 등록되었을 때 발생하는 이벤트입니다. 이 시점부터 codeId가 유효해집니다.</p>
<p>파라미터</p>
<ul>
<li>codeId: 새롭게 부여된 코드 id.</li>
<li>codeHash: 암호화된 코드의 keccak256 해시값.</li>
<li>cipherCid: 암호화된 코드 바이너리의 IPFS CID.</li>
<li>publisher: 배포자의 주소.</li>
</ul>
<p><strong>CodeUpdated</strong></p>
<p>기존 코드나 메타데이터(CID)가 갱신되었을 때 발생하는 이벤트입니다. 핫픽스, 새 빌드 배포 시 기록됩니다.</p>
<p>파라미터</p>
<ul>
<li>codeId: 새롭게 부여된 코드 id.</li>
<li>codeHash: 암호화된 코드의 keccak256 해시값.</li>
<li>cipherCid: 암호화된 코드 바이너리의 IPFS CID.</li>
<li>publisher: 배포자의 주소.</li>
</ul>
<p><strong>LicenseIssued</strong></p>
<p>라이센스 토큰를 발행할 때 발생하는 이벤트입니다.</p>
<p>파라미터</p>
<ul>
<li>codeId: 라이센스 토큰 발급 대상의 코드 ID.</li>
<li>to: 수령자 계정.</li>
<li>runs: 부여된 실행 가능 횟수</li>
<li>expiry: 만료 타임스탬프. 더 미래 값이면 갱신.</li>
</ul>
<p><strong>LicenseRevoked</strong></p>
<p>소유자가 특정 계정에 대한 라이센스를 강제 소각할 때 발생합니다.</p>
<p>파라미터</p>
<ul>
<li>codeId: 라이센스 토큰 취소 대상의 코드 ID.</li>
<li>account: 소각 대상 계정.</li>
<li>burned: 소각된 실행 가능 횟수.</li>
</ul>
<p><strong>CodePaused</strong></p>
<p>해당 코드의 온체인 실행이 일시정지할 때 발생합니다. 이후 사용자는 실행을 요청할 수 없습니다.</p>
<p>파라미터</p>
<ul>
<li>codeId: 일시 정지된 코드 ID.</li>
</ul>
<p><strong>CodeUnpaused</strong></p>
<p>정지되었던 코드의 온체인 실행이 재개할 때 발생합니다.</p>
<p>파라미터</p>
<ul>
<li>codeId: 재개한 코드 ID.</li>
</ul>
<p><strong>RunRequested</strong></p>
<p>사용자가 코드 실행(다운)을 요청할 때 발생합니다. 이 이벤트는 오프체인 실행 파이프라인(위원회/키조합/복호화/전달)을 트리거합니다.</p>
<p>파라미터</p>
<ul>
<li>codeId: 실행 대상 코드의 ID.</li>
<li>user: 실행을 요청한 사용자의 주소.</li>
<li>recipientPubKey: 코드를 복호화할 수 있도록 하는 키 조각를 받기 위해 사용되는 공개키.</li>
<li>blockTimestamp: 이벤트 발생 시점의 블록 타임스탬프.</li>
</ul>
<h3 is-upgraded>외부 로직</h3>
<p><code>supportsInterface(bytes4 interfaceId) → bool</code></p>
<p>이 컨트랙트가 특정 인터페이스를 지원하는지 반환합니다.</p>
<p><code>registerCode(bytes32 codeHash, string cipherCid) → uint256 codeId</code></p>
<p>신규 코드를 등록하고, 호출자를 해당 코드의 소유자로 설정합니다.</p>
<p><code>updateCodeMetadata(uint256 codeId, bytes32 newCodeHash, string newCipherCid)</code></p>
<p>코드의 해시/CID를 갱신합니다.</p>
<p><code>pauseCodeExecution(uint256 codeId)</code></p>
<p>해당 코드의 실행을 일시정지합니다.</p>
<p><code>unpauseCodeExecution(uint256 codeId)</code></p>
<p>정지 상태의 코드를 재개합니다.</p>
<p><code>issueLicense(uint256 codeId, address to, uint256 runs, uint256 expiryTimestamp)</code></p>
<p>특정 계정에 **라이센스 토큰(ERC-1155)**을 발급합니다.</p>
<p><code>revokeUserLicense(address account, uint256 codeId)</code></p>
<p>대상 계정의 라이선스 토큰을 전량 소각합니다.</p>
<p><code>requestCodeExecution(uint256 codeId, bytes recipientPubKey)</code></p>
<p>1회 실행을 요청하고 요청자의 실행권을 1 소각합니다. 오프체인 파이프라인이 이 이벤트를 구독해 결과를 처리/전달합니다.</p>
<h3 is-upgraded>View Helper</h3>
<p>읽기 전용으로 코드 상태/메타데이터를 빠르게 확인하는 헬퍼들입니다.트랜잭션 제출 전에 가용성 판단이나 UI 표시에 활용할 예정입니다.</p>
<p><strong>checkCodeActive(uint256 codeId) → bool</strong></p>
<p>해당 코드가 활성화 상태(존재하며 일시정지 상태가 아님)인지 확인합니다.</p>
<p><strong>checkCodeExists(uint256 codeId) → bool</strong></p>
<p>해당 코드가 등록되어 있는지 여부를 확인합니다.</p>
<p><strong>uri(uint256 id) → string</strong></p>
<p>ERC-1155 표준 메타데이터 URI를 반환합니다.</p>
<p>이제 <code>LicenseManager.sol</code>을 작성해봅시다.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {ERC1155} from &#34;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&#34;;
import {AccessControl} from &#34;@openzeppelin/contracts/access/AccessControl.sol&#34;;
import {ILicenseManager} from &#34;./interfaces/ILicenseManager.sol&#34;;

contract LicenseManager is ERC1155, AccessControl, ILicenseManager {

}
</code></pre>
<p>먼저 외부 라이브러리를 살펴봅시다.</p>
<ol type="1">
<li>AccessControl AccessControl은 스마트 컨트랙트의 함수 호출 권한을 &#34;역할(Role)&#34; 단위로 관리할 수 있게 해주는 모듈입니다. 역할은 bytes32 식별자(e.g. keccak256(&#34;MINTER_ROLE&#34;))로 정의하며, 해당 역할을 가진 주소만 특정 함수(또는 로직)를 실행할 수 있도록 제한합니다. 이를 통해 관리자, 민터, 버너 등 업무/권한 분리가 명확해지며, 권한 변경이 필요할 때도 역할 부여/회수만으로 안전하게 운용할 수 있습니다.</li>
<li>ERC1155 EIP-1155 멀티 토큰 표준의 OpenZeppelin 기본 컨트랙트 구현을 가져옵니다. 하나의 컨트랙트에서 여러 토큰 ID를 관리하며, 각 ID는 &#34;대체 가능(FT)처럼 수량형&#34; 또는 &#34;대체 불가능(NFT)처럼 1개&#34;로 사용할 수 있습니다. EIP-1155에 대해서는 밑에서 알아봅시다.</li>
<li>ERC165 ERC-165는 스마트 컨트랙트가 자신이 어떤 표준 인터페이스를 구현했는지 외부에서 확인할 수 있도록 정의한 <strong>인터페이스 탐지 규약입니다. </strong><code>supportsInterface(bytes4 interfaceId)</code> 함수를 통해 특정 인터페이스 식별자(interfaceId)를 지원하는지 true 또는 false로 응답하며, 이를 통해 다른 컨트랙트가 상호운용성을 안전하게 판단할 수 있습니다. 인터페이스 식별자는 인터페이스의 모든 function selectors를 XOR 연산해 계산하며, ERC165 자체의 식별자는 <strong>0x01ffc9a7로</strong> 고정되어 있습니다. OpenZeppelin이 정의한 표준 IERC165 인터페이스에 따라 <code>supportsInterface</code> 함수를 구현함으로써 컨트랙트가 ERC-721, ERC-1155 등 다양한 표준과의 호환성을 명확히 선언하고, 외부에서 이를 검증 가능하게 만들 수 있습니다.</li>
</ol>
<aside class="special"><p><strong>토큰(Token)</strong></p>
<p>스마트 컨트랙트에서 토큰(Token)은 블록체인 위에서 자산이나 권리를 표현하는 기본적인 단위입니다. 이를 통해 화폐, 포인트, 게임 아이템, 예술 작품 등 다양한 가치를 디지털화할 수 있습니다. 이더리움에서는 토큰의 규격을 표준으로 정의해 두었으며, 이를 ERC라고 부릅니다. ERC는 &#34;Ethereum Request for Comment&#34;의 약자로, 누구나 같은 규칙에 맞춰 토큰을 만들고 사용할 수 있도록 합니다. 가장 널리 알려진 표준은 ERC-20, ERC-721, 그리고 ERC-1155입니다.</p>
<p><strong>ERC-20</strong></p>
<p>ERC-20은 <strong>대체 가능 토큰(fungible token)</strong>, 즉 서로 동일한 가치를 가진 토큰을 정의한 표준입니다. 예를 들어, 1개의 ERC-20 토큰은 다른 1개의 ERC-20 토큰과 완전히 같은 가치를 가집니다. 이러한 특성 때문에 ERC-20은 주로 <strong>교환 가능하고 분할 가능한 자산</strong>을 표현하는 데에 사용됩니다. 예를 들어 10개의 토큰이 있다면 이를 5개와 5개로 나누거나 3개와 7개로 나눌 수 있으며, 서로 교환해도 가치에 차이가 없습니다. 실제로 USDT, USDC와 같은 스테이블 코인들이 ERC-20을 기반으로 만들어졌습니다. 이 표준을 따르면 잔액을 확인하거나 전송을 요청하는 등의 기본적인 기능을 동일하게 구현할 수 있기 때문에, 다양한 지갑이나 거래소에서 호환성이 보장됩니다.</p>
<p><strong>ERC-721</strong></p>
<p>ERC-721은 <strong>대체 불가능 토큰</strong>, 즉 NFT(Non-fungible token)를 정의한 표준입니다. ERC-20과 달리 ERC-721 토큰은 각각 고유한 식별자를 가지며, 동일한 가치를 가질 수 없습니다. 예를 들어, 하나의 그림 파일을 나타내는 NFT와 또 다른 그림 파일을 나타내는 NFT는 서로 다르고 교환 불가능합니다. 따라서 ERC-721은 디지털 예술품, 수집품, 게임 아이템, 부동산 토큰화 등 <strong>개별 자산의 고유성을 표현해야</strong> 하는 경우에 활용됩니다. 대표적으로 CryptoKitties와 같은 게임의 아이템, 그리고 Bored Ape Yacht Club과 같은 예술 NFT 프로젝트들이 ERC-721 표준을 따릅니다. 이 표준에서는 누가 특정 NFT를 소유하고 있는지 확인하거나, NFT의 소유권을 다른 사람에게 이전하거나, 토큰에 연결된 메타데이터(이미지, 설명 등)에 접근하는 기능을 제공합니다.</p>
<p><strong>ERC-1155</strong></p>
<p>ERC-1155는 ERC-20과 ERC-721의 장점을 결합한 멀티 토큰 표준입니다. 하나의 컨트랙트에서 여러 종류의 토큰을 동시에 관리할 수 있으며, 대체 가능 토큰과 대체 불가능 토큰을 모두 발행할 수 있습니다. 예를 들어 게임에서 흔히 사용되는 구조를 생각해 보면, 일반적인 소비형 아이템인 ‘물약&#39;은 ERC-20처럼 동일한 성격을 가진 대체 가능 토큰으로 표현할 수 있고, 유일한 전설 무기는 ERC-721처럼 고유한 NFT로 표현할 수 있습니다. ERC-1155를 이용하면 이 모든 자산을 하나의 컨트랙트에서 관리할 수 있고, 여러 개의 토큰을 한 번에 전송할 수도 있기 때문에 가스 비용을 절감할 수 있습니다. 이러한 효율성 때문에 메타버스, 게임, 복합 자산 플랫폼에서 널리 사용되고 있습니다. 이번에 만들 라이센스 토큰도 ERC-1155 기반으로 만듭니다.</p>
</aside>
<h2 is-upgraded>contructor와 전역변수</h2>
<p>작성된 contract에 contructor와 전역변수를 정의해봅시다.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {ERC1155} from &#34;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&#34;;
import {AccessControl} from &#34;@openzeppelin/contracts/access/AccessControl.sol&#34;;
import {ILicenseManager} from &#34;./interfaces/ILicenseManager.sol&#34;;

contract LicenseManager is ERC1155, AccessControl, ILicenseManager {
    bytes32 public constant ADMIN_ROLE = DEFAULT_ADMIN_ROLE;

    /* ========= 구조/상태 ========= */

    struct CodeInfo {
        bytes32 codeHash; // code를 keccak256로 암호화한 값
        string cipherCid; // 암호화 파일의 IPFS CID
        bool paused; // 실행 일시정지 여부
        bool exists; // 존재 플래그
        address owner; // 소유자 주소
    }

    // codeId =&gt; CodeInfo
    mapping(uint256 =&gt; CodeInfo) private _codes;

    // account =&gt; codeId =&gt; expiry
    // 계정별 만료시간: expiry[user][codeId] = timestamp
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) private _expiry;

    uint256 private _nextCodeId = 1;

    /* ========= 생성자/기본 설정 ========= */
    constructor(string memory baseUri) ERC1155(baseUri) {
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    // ERC165 통합 오버라이드: ERC1155, AccessControl, ILicenseManager에 대한 선언을 모두 해결
    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        override(ERC1155, AccessControl, ILicenseManager)
        returns (bool)
    {
        return
            interfaceId == type(ILicenseManager).interfaceId ||
            super.supportsInterface(interfaceId);
    }
}
</code></pre>
<p><code>ADMIN_ROLE</code>는 AccessControl의 <code>DEFAULT_ADMIN_ROLE</code>을 그대로 이용합니다. 컨트랙트의 모든 관리 권한을 가진 주체를 구분하기 위해 사용됩니다.</p>
<p><code>CodeInfo</code> 구조체는 코드의 메타데이터를 저장하는 틀로, 코드의 해시(codeHash), 암호화된 파일의 IPFS 주소(cipherCid), 실행 일시정지 여부(paused), 등록 여부(exists), 그리고 코드 소유자 주소(owner)를 포함합니다. <code>_codes</code>는 각 코드 ID(codeId)에 대응하는 CodeInfo를 저장해 코드를 개별적으로 관리하며, <code>_expiry</code>는 사용자 주소와 코드 ID를 키로 하여 해당 라이선스의 만료 시점을 기록합니다. <code>_nextCodeId</code>는 새 코드를 등록할 때 부여할 다음 코드 ID를 추적하는 카운터입니다.</p>
<p>constructor는 배포 시점에 한 번 실행되며, 상속받은 ERC1155의 생성자에 baseUri를 전달해 토큰 메타데이터의 기본 경로를 설정합니다. 또한 <code>_grantRole(ADMIN_ROLE, msg.sender)</code>를 호출하여 배포자에게 관리자 권한을 부여함합니다.</p>
<p><code>supportsInterface</code>는 ERC-165 인터페이스 탐지 규약을 따름을 보여주기 위한 함수입니다. 먼저 interfaceId == type(ILicenseManager).interfaceId를 검사해 이 컨트랙트가 커스텀 인터페이스인 ILicenseManager 를 직접 지원함을 명시합니다. 그 외의 경우에는 <code>super.supportsInterface(interfaceId)</code>를 호출해 상위 클래스(ERC1155, AccessControl)가 이미 지원을 선언한 표준들에 대한 판정을 체이닝으로 위임합니다.</p>
<h2 is-upgraded>기능에 따른 함수</h2>
<p>작성된 contract에 함수의 뼈대를 작성해봅시다. 함수명, 파라미터, 반환값 등은 ILicenseManager와 동일하게 작성하면 됩니다.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {ERC1155} from &#34;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&#34;;
import {AccessControl} from &#34;@openzeppelin/contracts/access/AccessControl.sol&#34;;
import {ILicenseManager} from &#34;./interfaces/ILicenseManager.sol&#34;;

contract LicenseManager is ERC1155, AccessControl, ILicenseManager {
    bytes32 public constant ADMIN_ROLE = DEFAULT_ADMIN_ROLE;

    /* ========= 구조/상태 ========= */

    struct CodeInfo {
        bytes32 codeHash; // code를 keccak256로 암호화한 값
        string cipherCid; // 암호화 파일의 IPFS CID
        bool paused; // 실행 일시정지 여부
        bool exists; // 존재 플래그
        address owner; // 소유자 주소
    }

    // codeId =&gt; CodeInfo
    mapping(uint256 =&gt; CodeInfo) private _codes;

    // account =&gt; codeId =&gt; expiry
    // 계정별 만료시간: expiry[user][codeId] = timestamp
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) private _expiry;

    uint256 private _nextCodeId = 1;

    /* ========= 생성자/기본 설정 ========= */
    constructor(string memory baseUri) ERC1155(baseUri) {
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    /* ========= 상태 조회 ========= */

    // code 조회
    function code(
        uint256 codeId
    ) external view override returns (bytes32, string memory, bool, bool) {
        // TODO implement code getter
    }

    // 코드 소유자 조회
    function codeOwner(
        uint256 codeId
    ) external view override returns (address) {
        // TODO implement owner getter
    }

    // 계정별 라이선스 만료시간 조회
    function licenseExpiry(
        address account,
        uint256 codeId
    ) external view override returns (uint256) {
        // TODO implement expiry getter
    }

    // 다음에 등록할 코드 ID 조회
    function nextCodeId() external view override returns (uint256) {
        // TODO implement nextCodeId getter
    }

    // ERC165 통합 오버라이드: ERC1155, AccessControl, ILicenseManager에 대한 선언을 모두 해결
    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        override(ERC1155, AccessControl, ILicenseManager)
        returns (bool)
    {
        return
            interfaceId == type(ILicenseManager).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ========= 함수 정의 ========= */

    // 코드 등록
    function registerCode(
        bytes32 codeHash,
        string calldata cipherCid
    ) external override returns (uint256 codeId) {
        // TODO implement code registration
    }

    // 코드 메타데이터 갱신. 소유자만 갱신 가능
    function updateCodeMetadata(
        uint256 codeId,
        bytes32 newCodeHash,
        string calldata newCipherCid
    ) external override {
        // TODO implement updating code metadata
    }

    // 코드 일시정지. 소유자 또는 관리자만 가능
    function pauseCodeExecution(uint256 codeId) external override {
        // TODO implement pausing code execution
    }

    // 코드 일시정지 해제. 소유자 또는 관리자만 가능
    function unpauseCodeExecution(uint256 codeId) external override {
        // TODO implement unpausing code execution
    }

    // 특정 사용자에게 라이선스 발급. 소유자만 가능
    function issueLicense(
        uint256 codeId,
        address to,
        uint256 runs,
        uint256 expiryTimestamp
    ) external override {
        // TODO implement issuing license
    }

    // 특정 사용자의 라이선스 전량 취소(소각). 소유자만 가능
    function revokeUserLicense(
        address account,
        uint256 codeId
    ) external override {
        // TODO implement revoking license
    }

    // 실행 요청. 1회 소진 + 이벤트 발생
    function requestCodeExecution(
        uint256 codeId,
        bytes calldata recipientPubKey
    ) external override {
        // TODO implement requestCodeExecution
    }

    /* ========= 뷰 헬퍼 ========= */

    // 코드가 존재하고 정지 상태가 아닌지 여부
    function checkCodeActive(
        uint256 codeId
    ) external view override returns (bool) {
        // TODO implement to get checkCodeActive
    }

    // 코드 존재 여부 확인
    function checkCodeExists(
        uint256 codeId
    ) external view override returns (bool) {
        // TODO implement to get checkCodeExists
    }

    // ERC1155의 메타데이터 URI를 code별로 반환
    function uri(
        uint256 id
    ) public view override(ERC1155, ILicenseManager) returns (string memory) {
        // TODO implement to uri
    }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="스마트 컨트랙트 작성" duration="0">
        <p>앞서 구현한 코드 뼈대를 토대로 함수를 구현하겠습니다. 먼저 상태 조회하는 함수입니다.</p>
<p>Solidity에서 public 상태 변수는 컴파일 시 자동으로 해당 변수명에 대한 getter가 생성됩니다. 외부 컨트랙트나 오프체인 클라이언트는 이 함수를 호출해 스토리지 값을 읽을 수 있고, internal 변수는 당연히 이렇게 노출되지 않습니다. 우리는 getter를 interface에서 명시적으로 정의해놓았기 때문에 getter를 구현하겠습니다. getter는 상태 변수의 값을 그대로 반환하면 됩니다.</p>
<h2 is-upgraded>code</h2>
<pre><code language="language-solidity" class="language-solidity">// code 조회
function code(
    uint256 codeId
) external view override returns (bytes32, string memory, bool, bool) {
    CodeInfo storage c = _codes[codeId];
    return (c.codeHash, c.cipherCid, c.paused, c.exists);
}
</code></pre>
<p>codeId로 storage에 저장된 code를 조회하고 관련 정보를 반환하는 함수입니다.</p>
<h2 is-upgraded>codeOwner</h2>
<pre><code language="language-solidity" class="language-solidity">// 코드 소유자 조회
function codeOwner(
uint256 codeId
) external view override returns (address) {
return _codes[codeId].owner;
}
</code></pre>
<p>codeId에 해당하는 코드 엔트리의 소유자 주소를 저장소에서 읽어 반환하는 함수입니다.</p>
<h2 is-upgraded>licenseExpiry</h2>
<pre><code language="language-solidity" class="language-solidity">// 계정별 라이선스 만료시간 조회
function licenseExpiry(
address account,
uint256 codeId
) external view override returns (uint256) {
return _expiry[account][codeId];
}
</code></pre>
<p>특정 account가 codeId에 대해 보유한 라이선스 만료 타임스탬프를 반환합니다. 값이 0이면 무기한(만료 없음)을 의미합니다.</p>
<h2 is-upgraded>nextCodeId</h2>
<pre><code language="language-solidity" class="language-solidity">// 다음에 등록할 코드 ID 조회
function nextCodeId() external view override returns (uint256) {
return _nextCodeId;
}
</code></pre>
<p>다음 registerCode 호출 시 부여될 다음 코드 ID 값을 조회하여 반환합니다. 내부 카운터로 관리되며 등록 시 1씩 증가합니다.</p>
<h2 is-upgraded>registerCode</h2>
<pre><code language="language-solidity" class="language-solidity">// 코드 등록
function registerCode(
    bytes32 codeHash,
    string calldata cipherCid
) external override returns (uint256 codeId) {
    require(codeHash != bytes32(0), &#34;Invalid codeHash&#34;);

    codeId = _nextCodeId++;
    _codes[codeId] = CodeInfo({
        codeHash: codeHash,
        cipherCid: cipherCid,
        paused: false,
        exists: true,
        owner: msg.sender
    });

    emit CodeRegistered(codeId, codeHash, cipherCid, msg.sender);
}
</code></pre>
<p>이제 본격적으로 기능을 위한 함수를 작성해봅시다. <code>registerCode</code>는 새 code를 등록하는 함수입니다. 하는 일은 크게 3가지입니다. 먼저, code에 대한 정보를 저장합니다. codeHash와 cipherCid를 받아 그대로 사용하고 exists는 true, paused는 false로 하여 storage에 저장합니다. 또한 이 함수를 호출한 주소(<code>msg.sender</code>)를 소유자로 설정합니다. 두 번째로 다음번에 호출되었을 때 저장할 위치를 변경하기 위해서 <code>_nextCodeId</code>를 증가시킵니다. 마지막으로 이벤트 <code>CodeRegistered</code>를 발행해 신규 코드 등록을 추적할 수 있게 합니다.</p>
<h2 is-upgraded>updateCodeMetadata</h2>
<pre><code language="language-solidity" class="language-solidity">// 코드 메타데이터 갱신. 소유자만 갱신 가능
function updateCodeMetadata(
    uint256 codeId,
    bytes32 newCodeHash,
    string calldata newCipherCid
) external override {
    _requireCodeExists(codeId);
    _requireCodeOwner(codeId);

    CodeInfo storage c = _codes[codeId];
    c.codeHash = newCodeHash;
    c.cipherCid = newCipherCid;

    emit CodeUpdated(codeId, newCodeHash, newCipherCid, msg.sender);
    // ERC1155
    emit URI(newCipherCid, codeId);
}
</code></pre>
<p><code>updateCodeMetadata</code>는 등록된 코드의 온체인 메타데이터를 갱신합니다. 기존에 storage에 저장된 code의 데이터를 갱신한 후 <code>CodeUpdated</code>와 <code>URI</code> 이벤트를 보내 갱신 사실을 인지하도록 합니다. 물론 코드가 존재하는지 여부를 먼저 파악해야합니다. code가 존재하는지 여부와 code의 소유자인지 판단, 소유자 혹은 관리자인지 판단하는 로직은 앞으로 자주 쓰이게 될 기능이므로 함수로 만들도록 합니다. 컨트랙트 하단에 다음의 코드를 붙여넣어 주세요.</p>
<pre><code language="language-solidity" class="language-solidity">/* ========= 내부 유틸 ========= */
function _requireCodeExists(uint256 codeId) internal view {
    require(_codes[codeId].exists, &#34;Code not found&#34;);
}

function _requireCodeOwner(uint256 codeId) internal view {
    require(
        _codes[codeId].owner == msg.sender,
        &#34;Caller is not the code owner&#34;
    );
}

function _requireCodeOwnerOrAdmin(uint256 codeId) internal view {
    if (hasRole(ADMIN_ROLE, msg.sender)) return;
    require(
        _codes[codeId].owner == msg.sender,
        &#34;Caller is neither code owner nor admin&#34;
    );
}
</code></pre>
<h2 is-upgraded>pauseCodeExecution &amp; unpauseCodeExecution</h2>
<pre><code language="language-solidity" class="language-solidity">// 코드 일시정지. 소유자 또는 관리자만 가능
function pauseCodeExecution(uint256 codeId) external override {
    _requireCodeExists(codeId);
    _requireCodeOwnerOrAdmin(codeId);
    require(!_codes[codeId].paused, &#34;Code already paused&#34;);

    _codes[codeId].paused = true;
    emit CodePaused(codeId);
}

// 코드 일시정지 해제. 소유자 또는 관리자만 가능
function unpauseCodeExecution(uint256 codeId) external override {
    _requireCodeExists(codeId);
    _requireCodeOwnerOrAdmin(codeId);
    require(_codes[codeId].paused, &#34;Code not paused&#34;);

    _codes[codeId].paused = false;
    emit CodeUnpaused(codeId);
}
</code></pre>
<p>특정 코드에 대한 실행 요청 기능만 일시정지/해제합니다. 소유자 또는 관리자만 호출할 수 있도록 구현합니다. 실행 요청시 정지되어 있으면 기능을 사용하지 못하도록 막아 라이센스 발급(issuing)은 허용합니다.</p>
<h2 is-upgraded>issueLicense</h2>
<pre><code language="language-solidity" class="language-solidity">// 특정 사용자에게 라이선스 발급. 소유자만 가능
function issueLicense(
    uint256 codeId,
    address to,
    uint256 runs,
    uint256 expiryTimestamp
) external override {
    _requireCodeExists(codeId);
    _requireCodeOwner(codeId);
    require(!_codes[codeId].paused, &#34;Code is paused&#34;);
    require(to != address(0), &#34;Invalid recipient&#34;);
    require(runs &gt; 0, &#34;Runs must be greater than 0&#34;);
    require(
        expiryTimestamp == 0 || expiryTimestamp &gt; block.timestamp,
        &#34;Invalid expiry&#34;
    );

    // 만료 갱신: 더 긴 쪽으로 확장(기존 만료가 더 길면 유지)
    uint256 prevTimestamp = _expiry[to][codeId];
    if (expiryTimestamp &gt; prevTimestamp) {
        _expiry[to][codeId] = expiryTimestamp;
    }

    _mint(to, codeId, runs, &#34;&#34;);
    emit LicenseIssued(codeId, to, runs, _expiry[to][codeId]);
}
</code></pre>
<p>소유자가 사용자에게 **라이센스 토큰(ERC-1155)**을 발급하는 함수입니다. 코드가 존재하고 정지 상태가 아님을 보장합니다. 발행하려는 토큰의 실행횟수나 만료시각이 유효한지 역시 검사해야 합니다. 만료 시각은 더 긴 값 우선 정책으로 갱신합니다(기존 만료가 더 길면 유지). 권한을 <code>_mint(to, codeId, runs, "")</code>로 부여하고 LicenseIssued 이벤트를 발행합니다.</p>
<aside class="special"><p><strong>_mint(address to, uint256 id, uint256 amount, bytes data)</strong></p>
<p><code>_mint</code>는 <strong>OpenZeppelin ERC-1155</strong>에서 토큰을 새로 발행해 수신자 to의 잔고에 id 토큰을 amount만큼 추가하는 내부 함수입니다. 가시성은 internal이라 내부 로직에서만 호출할 수 있습니다. 호출 시 to가 영(0)주소면 즉시 되돌리고, 전처리 훅(<code>_beforeTokenTransfer</code>)을 호출한 뒤 스토리지의 잔고를 증가시키고 <code>TransferSingle(operator, address(0), to, id, amount)</code> 이벤트로 minting되었음을 알립니다. 이어서 수신자가 컨트랙트 주소인 경우 ERC-1155 수신 인터페이스인 IERC1155Receiver.onERC1155Received를 호출해 정상 수신 셀렉터를 반환하는지 확인하며, 그렇지 않으면 되돌립니다. 마지막으로 후처리 훅(<code>_afterTokenTransfer</code>)이 호출되어 확장 포인트를 제공합니다.</p>
</aside>
<h2 is-upgraded>revokeUserLicense</h2>
<pre><code language="language-solidity" class="language-solidity">// 특정 사용자의 라이선스 전량 취소(소각). 소유자만 가능
function revokeUserLicense(
    address account,
    uint256 codeId
) external override {
    _requireCodeExists(codeId);
    _requireCodeOwner(codeId);
    uint256 bal = balanceOf(account, codeId);
    require(
        bal &gt; 0 || _expiry[account][codeId] &gt; 0,
        &#34;No license to revoke&#34;
    );

    if (bal &gt; 0) {
        _burn(account, codeId, bal);
    }
    _expiry[account][codeId] = 0;

    emit LicenseRevoked(codeId, account, bal);
}
</code></pre>
<p>특정 사용자의 해당 코드에 대한 실행권을 전량 회수합니다. 소유자만 호출 가능하며, 잔고가 있으면 <code>_burn(account, codeId, balance)</code>로 소각하고 만료도 0으로 초기화합니다. LicenseRevoked 이벤트를 통해 회수된 수량을 전파합니다.</p>
<aside class="special"><p><strong>_burn(account, codeId, balance)</strong></p>
<p><code>_burn</code>는 <strong>OpenZeppelin ERC-1155</strong>에서 주소 <code>from</code>이 보유한 <code>id</code> 토큰을 <code>amount</code>만큼 영구 소각하는 내부 함수입니다. <code>_mint</code>와 동일하게 가시성은 internal이고 권한 검증을 끝낸 뒤 내부적으로 호출하는 게 일반적입니다. 실행 흐름은 대체로 다음과 같습니다:</p>
<p>먼저 <code>from != address(0)</code>를 확인하고, 전처리 훅 <code>_beforeTokenTransfer</code>을 호출합니다. 이어서 <code>from</code>의 잔고가 <code>amount</code> 이상인지 확인한 후(부족하면 revert) 잔고를 감소시키고, <code>TransferSingle(operator, from, address(0), id, amount)</code> 이벤트를 내보냅니다. 마지막으로 후처리 훅 <code>_afterTokenTransfer</code>가 호출되어 확장 포인트를 제공합니다.</p>
</aside>
<aside class="warning"><p><strong>Warning</strong></p>
<p>안전성 측면에서 <code>_burn</code>은 수신 컨트랙트 콜백을 호출하지 않습니다. 따라서 권한과 전제조건 검증은 반드시 호출하는 쪽에서 해야 합니다.</p>
</aside>
<h2 is-upgraded>requestCodeExecution</h2>
<pre><code language="language-solidity" class="language-solidity">// 실행 요청. 1회 소진 + 이벤트 발생
function requestCodeExecution(
    uint256 codeId,
    bytes calldata recipientPubKey
) external override {
    _requireCodeExists(codeId);
    require(!_codes[codeId].paused, &#34;Code is paused&#34;);
    require(balanceOf(msg.sender, codeId) &gt; 0, &#34;Insufficient runs&#34;);
    uint256 expiry = _expiry[msg.sender][codeId];
    require(expiry == 0 || block.timestamp &lt;= expiry, &#34;License expired&#34;);

    // 1회 소진
    _burn(msg.sender, codeId, 1);

    emit RunRequested(codeId, msg.sender, recipientPubKey, block.timestamp);
}
</code></pre>
<p>사용자가 라이센스의 실행권을 1회 소모하여 실행을 요청하는 함수입니다. 코드가 존재하며 정지되지 않았고, 호출자가 해당 codeId 실행권 잔고를 보유하고 있으며, 만료되지 않았음을 검증합니다. 그 후 <code>_burn(msg.sender, codeId, 1)</code>로 1회를 소모하고, RunRequested 이벤트에 recipientPubKey와 timestamp를 담아 발행합니다. 위원회는 이 이벤트를 구독해 실제 실행 절차를 진행하게 됩니다.</p>
<h2 is-upgraded>View Helper</h2>
<p>View Helper는 컨트랙트의 상태를 읽기(read-only)위해 사용하는 함수입니다. 오프체인이나 다른 컨트랙트에서 안전하게 상태를 확인하고 결과만 받기 위해 돕습니다. 트랙잭션 없이 <code>eth_call</code>로 부르면 가스가 들지 않고, 트랜잭션 내부에서 호출할 때만 가스가 필요합니다. 구현할 view helper는 code가 active(존재하고 정지 상태가 아님)인지 판단하는 함수, code가 존재하는지에 판단하는 함수, ERC1155의 메타데이터 URI를 가져오는 함수입니다.</p>
<pre><code language="language-solidity" class="language-solidity">/* ========= 뷰 헬퍼 ========= */

// 코드가 존재하고 정지 상태가 아닌지 여부
function checkCodeActive(
    uint256 codeId
) external view override returns (bool) {
    return _codes[codeId].exists &amp;&amp; !_codes[codeId].paused;
}

// 코드 존재 여부 확인
function checkCodeExists(
    uint256 codeId
) external view override returns (bool) {
    return _codes[codeId].exists;
}

// ERC1155의 메타데이터 URI를 code별로 반환
function uri(
    uint256 id
) public view override(ERC1155, ILicenseManager) returns (string memory) {
    CodeInfo storage c = _codes[id];
    if (bytes(c.cipherCid).length &gt; 0) {
        return c.cipherCid;
    }
    // fallback: ERC1155 기본 동작
    return super.uri(id);
}
</code></pre>
<h2 is-upgraded>마무리 및 테스트</h2>
<p>이제 LicenseManager 컨트랙트 작성을 완료했습니다. 전체 코드는 다음과 같습니다.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {ERC1155} from &#34;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&#34;;
import {AccessControl} from &#34;@openzeppelin/contracts/access/AccessControl.sol&#34;;
import {ILicenseManager} from &#34;./interfaces/ILicenseManager.sol&#34;;

contract LicenseManager is ERC1155, AccessControl, ILicenseManager {
    bytes32 public constant ADMIN_ROLE = DEFAULT_ADMIN_ROLE;

    /* ========= 구조/상태 ========= */

    struct CodeInfo {
        bytes32 codeHash; // code를 keccak256로 암호화한 값
        string cipherCid; // 암호화 파일의 IPFS CID
        bool paused; // 실행 일시정지 여부
        bool exists; // 존재 플래그
        address owner; // 소유자 주소
    }

    // codeId =&gt; CodeInfo
    mapping(uint256 =&gt; CodeInfo) private _codes;

    // account =&gt; codeId =&gt; expiry
    // 계정별 만료시간: expiry[user][codeId] = timestamp
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) private _expiry;

    uint256 private _nextCodeId = 1;

    /* ========= 생성자/기본 설정 ========= */
    constructor(string memory baseUri) ERC1155(baseUri) {
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    /* ========= 상태 조회 ========= */

    // code 조회
    function code(
        uint256 codeId
    ) external view override returns (bytes32, string memory, bool, bool) {
        CodeInfo storage c = _codes[codeId];
        return (c.codeHash, c.cipherCid, c.paused, c.exists);
    }

    // 코드 소유자 조회
    function codeOwner(
        uint256 codeId
    ) external view override returns (address) {
        return _codes[codeId].owner;
    }

    // 계정별 라이선스 만료시간 조회
    function licenseExpiry(
        address account,
        uint256 codeId
    ) external view override returns (uint256) {
        return _expiry[account][codeId];
    }

    // 다음에 등록할 코드 ID 조회
    function nextCodeId() external view override returns (uint256) {
        return _nextCodeId;
    }

    // ERC165 통합 오버라이드: ERC1155, AccessControl, ILicenseManager에 대한 선언을 모두 해결
    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        override(ERC1155, AccessControl, ILicenseManager)
        returns (bool)
    {
        return
            interfaceId == type(ILicenseManager).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ========= 함수 정의 ========= */

    // 코드 등록
    function registerCode(
        bytes32 codeHash,
        string calldata cipherCid
    ) external override returns (uint256 codeId) {
        require(codeHash != bytes32(0), &#34;Invalid codeHash&#34;);

        codeId = _nextCodeId++;
        _codes[codeId] = CodeInfo({
            codeHash: codeHash,
            cipherCid: cipherCid,
            paused: false,
            exists: true,
            owner: msg.sender
        });

        emit CodeRegistered(codeId, codeHash, cipherCid, msg.sender);
    }

    // 코드 메타데이터 갱신. 소유자만 갱신 가능
    function updateCodeMetadata(
        uint256 codeId,
        bytes32 newCodeHash,
        string calldata newCipherCid
    ) external override {
        _requireCodeExists(codeId);
        _requireCodeOwner(codeId);

        CodeInfo storage c = _codes[codeId];
        c.codeHash = newCodeHash;
        c.cipherCid = newCipherCid;

        emit CodeUpdated(codeId, newCodeHash, newCipherCid, msg.sender);
        // ERC1155
        emit URI(newCipherCid, codeId);
    }

    // 코드 일시정지. 소유자 또는 관리자만 가능
    function pauseCodeExecution(uint256 codeId) external override {
        _requireCodeExists(codeId);
        _requireCodeOwnerOrAdmin(codeId);
        require(!_codes[codeId].paused, &#34;Code already paused&#34;);

        _codes[codeId].paused = true;
        emit CodePaused(codeId);
    }

    // 코드 일시정지 해제. 소유자 또는 관리자만 가능
    function unpauseCodeExecution(uint256 codeId) external override {
        _requireCodeExists(codeId);
        _requireCodeOwnerOrAdmin(codeId);
        require(_codes[codeId].paused, &#34;Code not paused&#34;);

        _codes[codeId].paused = false;
        emit CodeUnpaused(codeId);
    }

    // 특정 사용자에게 라이선스 발급. 소유자만 가능
    function issueLicense(
        uint256 codeId,
        address to,
        uint256 runs,
        uint256 expiryTimestamp
    ) external override {
        _requireCodeExists(codeId);
        _requireCodeOwner(codeId);
        require(!_codes[codeId].paused, &#34;Code is paused&#34;);
        require(to != address(0), &#34;Invalid recipient&#34;);
        require(runs &gt; 0, &#34;Runs must be greater than 0&#34;);
        require(
            expiryTimestamp == 0 || expiryTimestamp &gt; block.timestamp,
            &#34;Invalid expiry&#34;
        );

        // 만료 갱신: 더 긴 쪽으로 확장(기존 만료가 더 길면 유지)
        uint256 prevTimestamp = _expiry[to][codeId];
        if (expiryTimestamp &gt; prevTimestamp) {
            _expiry[to][codeId] = expiryTimestamp;
        }

        _mint(to, codeId, runs, &#34;&#34;);
        emit LicenseIssued(codeId, to, runs, _expiry[to][codeId]);
    }

    // 특정 사용자의 라이선스 전량 취소(소각). 소유자만 가능
    function revokeUserLicense(
        address account,
        uint256 codeId
    ) external override {
        _requireCodeExists(codeId);
        _requireCodeOwner(codeId);
        uint256 bal = balanceOf(account, codeId);
        require(
            bal &gt; 0 || _expiry[account][codeId] &gt; 0,
            &#34;No license to revoke&#34;
        );

        if (bal &gt; 0) {
            _burn(account, codeId, bal);
        }
        _expiry[account][codeId] = 0;

        emit LicenseRevoked(codeId, account, bal);
    }

    // 실행 요청. 1회 소진 + 이벤트 발생
    function requestCodeExecution(
        uint256 codeId,
        bytes calldata recipientPubKey
    ) external override {
        _requireCodeExists(codeId);
        require(!_codes[codeId].paused, &#34;Code is paused&#34;);
        require(balanceOf(msg.sender, codeId) &gt; 0, &#34;Insufficient runs&#34;);
        uint256 expiry = _expiry[msg.sender][codeId];
        require(expiry == 0 || block.timestamp &lt;= expiry, &#34;License expired&#34;);

        // 1회 소진
        _burn(msg.sender, codeId, 1);

        emit RunRequested(codeId, msg.sender, recipientPubKey, block.timestamp);
    }

    /* ========= 뷰 헬퍼 ========= */

    // 코드가 존재하고 정지 상태가 아닌지 여부
    function checkCodeActive(
        uint256 codeId
    ) external view override returns (bool) {
        return _codes[codeId].exists &amp;&amp; !_codes[codeId].paused;
    }

    // 코드 존재 여부 확인
    function checkCodeExists(
        uint256 codeId
    ) external view override returns (bool) {
        return _codes[codeId].exists;
    }

    // ERC1155의 메타데이터 URI를 code별로 반환
    function uri(
        uint256 id
    ) public view override(ERC1155, ILicenseManager) returns (string memory) {
        CodeInfo storage c = _codes[id];
        if (bytes(c.cipherCid).length &gt; 0) {
            return c.cipherCid;
        }
        // fallback: ERC1155 기본 동작
        return super.uri(id);
    }

    /* ========= 내부 유틸 ========= */
    function _requireCodeExists(uint256 codeId) internal view {
        require(_codes[codeId].exists, &#34;Code not found&#34;);
    }

    function _requireCodeOwner(uint256 codeId) internal view {
        require(
            _codes[codeId].owner == msg.sender,
            &#34;Caller is not the code owner&#34;
        );
    }

    function _requireCodeOwnerOrAdmin(uint256 codeId) internal view {
        if (hasRole(ADMIN_ROLE, msg.sender)) return;
        require(
            _codes[codeId].owner == msg.sender,
            &#34;Caller is neither code owner nor admin&#34;
        );
    }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="IPFS 사용법 익히기" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="축하합니다" duration="1">
        <p>축하합니다! 성공적으로 License관련 컨트랙트를 작성하였습니다. 다음 시간에는 위원회 관련 컨트랙트 개발과 기존 컨트랙트에서 보안할 점을 채우도록 하겠습니다.</p>
<h2 is-upgraded>도움이 될 만한 자료</h2>
<ol type="1">
<li><a href="https://cryptozombies.io" target="_blank">크립토 좀비</a>: 좀비 게임을 만들면서 Blockchain 기반 Dapp 기반을 학습할 수 있습니다. Solidity Course부터 진행하는 것을 추천드립니다.</li>
<li><a href="https://cloud.google.com/application/web3" target="_blank">Google Cloud Web3</a>: 구글 클라우드에서 만든 Web3 개발자 도구입니다. Ethureum(Sepolia)을 비롯한 다양한 코인의 Faucet을 지원합니다.</li>
<li><a href="https://remix.ethereum.org" target="_blank">Remix IDE</a>: 온라인 Remix IDE입니다.</li>
<li><a href="https://hardhat.org" target="_blank">Hardhat</a>: Hardhat 공식 웹 페이지입니다.</li>
</ol>
<h2 is-upgraded>참고 자료</h2>
<ol type="1">
<li><a href="https://docs.openzeppelin.com/contracts" target="_blank">openzeppelin의 contract관련 개발 문서</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank">EIP-20: ERC-20(Token Standard)</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-165" target="_blank">EIP-165: ERC-165(Standard Interface Detection)</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-721" target="_blank">EIP-721: ERC-721(Non-Fungible Token Standard)</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-1155" target="_blank">EIP-1155: ERC-1155(Multi Token Standa)</a></li>
</ol>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
